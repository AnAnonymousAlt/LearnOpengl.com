#include "../include/Helper_functions.h"



const glm::vec4 Color::aliceblue = { 0.941f, 0.973f, 1.000f, 1.0 };
const glm::vec4 Color::antiquewhite = { 0.980f, 0.922f, 0.843f, 1.0 };
const glm::vec4 Color::aqua = { 0.000f, 1.000f, 1.000f, 1.0 };
const glm::vec4 Color::aquamarine = { 0.498f, 1.000f, 0.831f, 1.0 };
const glm::vec4 Color::azure = { 0.941f, 1.000f, 1.000f, 1.0 };
const glm::vec4 Color::beige = { 0.961f, 0.961f, 0.863f, 1.0 };
const glm::vec4 Color::bisque = { 1.000f, 0.894f, 0.769f, 1.0 };
const glm::vec4 Color::black = { 0.000f, 0.000f, 0.000f, 1.0 };
const glm::vec4 Color::blanchedalmond = { 1.000f, 0.922f, 0.804f, 1.0 };
const glm::vec4 Color::blue = { 0.000f, 0.000f, 1.000f, 1.0 };
const glm::vec4 Color::blueviolet = { 0.541f, 0.169f, 0.886f, 1.0 };
const glm::vec4 Color::brown = { 0.647f, 0.165f, 0.165f, 1.0 };
const glm::vec4 Color::burlywood = { 0.871f, 0.722f, 0.529f, 1.0 };
const glm::vec4 Color::cadetblue = { 0.373f, 0.620f, 0.627f, 1.0 };
const glm::vec4 Color::chartreuse = { 0.498f, 1.000f, 0.000f, 1.0 };
const glm::vec4 Color::chocolate = { 0.824f, 0.412f, 0.118f, 1.0 };
const glm::vec4 Color::coral = { 1.000f, 0.498f, 0.314f, 1.0 };
const glm::vec4 Color::cornflowerblue = { 0.392f, 0.584f, 0.929f, 1.0 };
const glm::vec4 Color::cornsilk = { 1.000f, 0.973f, 0.863f, 1.0 };
const glm::vec4 Color::crimson = { 0.863f, 0.078f, 0.235f, 1.0 };
const glm::vec4 Color::cyan = { 0.000f, 1.000f, 1.000f, 1.0 };
const glm::vec4 Color::darkblue = { 0.000f, 0.000f, 0.545f, 1.0 };
const glm::vec4 Color::darkcyan = { 0.000f, 0.545f, 0.545f, 1.0 };
const glm::vec4 Color::darkgoldenrod = { 0.722f, 0.525f, 0.043f, 1.0 };
const glm::vec4 Color::darkgray = { 0.663f, 0.663f, 0.663f, 1.0 };
const glm::vec4 Color::darkgreen = { 0.000f, 0.392f, 0.000f, 1.0 };
const glm::vec4 Color::darkgrey = { 0.663f, 0.663f, 0.663f, 1.0 };
const glm::vec4 Color::darkkhaki = { 0.741f, 0.718f, 0.420f, 1.0 };
const glm::vec4 Color::darkmagenta = { 0.545f, 0.000f, 0.545f, 1.0 };
const glm::vec4 Color::darkolivegreen = { 0.333f, 0.420f, 0.184f, 1.0 };
const glm::vec4 Color::darkorange = { 1.000f, 0.549f, 0.000f, 1.0 };
const glm::vec4 Color::darkorchid = { 0.600f, 0.196f, 0.800f, 1.0 };
const glm::vec4 Color::darkred = { 0.545f, 0.000f, 0.000f, 1.0 };
const glm::vec4 Color::darksalmon = { 0.914f, 0.588f, 0.478f, 1.0 };
const glm::vec4 Color::darkseagreen = { 0.561f, 0.737f, 0.561f, 1.0 };
const glm::vec4 Color::darkslateblue = { 0.282f, 0.239f, 0.545f, 1.0 };
const glm::vec4 Color::darkslategray = { 0.184f, 0.310f, 0.310f, 1.0 };
const glm::vec4 Color::darkslategrey = { 0.184f, 0.310f, 0.310f, 1.0 };
const glm::vec4 Color::darkturquoise = { 0.000f, 0.808f, 0.820f, 1.0 };
const glm::vec4 Color::darkviolet = { 0.580f, 0.000f, 0.827f, 1.0 };
const glm::vec4 Color::deeppink = { 1.000f, 0.078f, 0.576f, 1.0 };
const glm::vec4 Color::deepskyblue = { 0.000f, 0.749f, 1.000f, 1.0 };
const glm::vec4 Color::dimgray = { 0.412f, 0.412f, 0.412f, 1.0 };
const glm::vec4 Color::dimgrey = { 0.412f, 0.412f, 0.412f, 1.0 };
const glm::vec4 Color::dodgerblue = { 0.118f, 0.565f, 1.000f, 1.0 };
const glm::vec4 Color::firebrick = { 0.698f, 0.133f, 0.133f, 1.0 };
const glm::vec4 Color::floralwhite = { 1.000f, 0.980f, 0.941f, 1.0 };
const glm::vec4 Color::forestgreen = { 0.133f, 0.545f, 0.133f, 1.0 };
const glm::vec4 Color::fuchsia = { 1.000f, 0.000f, 1.000f, 1.0 };
const glm::vec4 Color::gainsboro = { 0.863f, 0.863f, 0.863f, 1.0 };
const glm::vec4 Color::ghostwhite = { 0.973f, 0.973f, 1.000f, 1.0 };
const glm::vec4 Color::gold = { 1.000f, 0.843f, 0.000f, 1.0 };
const glm::vec4 Color::goldenrod = { 0.855f, 0.647f, 0.125f, 1.0 };
const glm::vec4 Color::gray = { 0.502f, 0.502f, 0.502f, 1.0 };
const glm::vec4 Color::green = { 0.000f, 0.502f, 0.000f, 1.0 };
const glm::vec4 Color::greenyellow = { 0.678f, 1.000f, 0.184f, 1.0 };
const glm::vec4 Color::grey = { 0.502f, 0.502f, 0.502f, 1.0 };
const glm::vec4 Color::honeydew = { 0.941f, 1.000f, 0.941f, 1.0 };
const glm::vec4 Color::hotpink = { 1.000f, 0.412f, 0.706f, 1.0 };
const glm::vec4 Color::indianred = { 0.804f, 0.361f, 0.361f, 1.0 };
const glm::vec4 Color::indigo = { 0.294f, 0.000f, 0.510f, 1.0 };
const glm::vec4 Color::ivory = { 1.000f, 1.000f, 0.941f, 1.0 };
const glm::vec4 Color::khaki = { 0.941f, 0.902f, 0.549f, 1.0 };
const glm::vec4 Color::lavender = { 0.902f, 0.902f, 0.980f, 1.0 };
const glm::vec4 Color::lavenderblush = { 1.000f, 0.941f, 0.961f, 1.0 };
const glm::vec4 Color::lawngreen = { 0.486f, 0.988f, 0.000f, 1.0 };
const glm::vec4 Color::lemonchiffon = { 1.000f, 0.980f, 0.804f, 1.0 };
const glm::vec4 Color::lightblue = { 0.678f, 0.847f, 0.902f, 1.0 };
const glm::vec4 Color::lightcoral = { 0.941f, 0.502f, 0.502f, 1.0 };
const glm::vec4 Color::lightcyan = { 0.878f, 1.000f, 1.000f, 1.0 };
const glm::vec4 Color::lightgoldenrodyellow = { 0.980f, 0.980f, 0.824f, 1.0 };
const glm::vec4 Color::lightgray = { 0.827f, 0.827f, 0.827f, 1.0 };
const glm::vec4 Color::lightgreen = { 0.565f, 0.933f, 0.565f, 1.0 };
const glm::vec4 Color::lightgrey = { 0.827f, 0.827f, 0.827f, 1.0 };
const glm::vec4 Color::lightpink = { 1.000f, 0.714f, 0.757f, 1.0 };
const glm::vec4 Color::lightsalmon = { 1.000f, 0.627f, 0.478f, 1.0 };
const glm::vec4 Color::lightseagreen = { 0.125f, 0.698f, 0.667f, 1.0 };
const glm::vec4 Color::lightskyblue = { 0.529f, 0.808f, 0.980f, 1.0 };
const glm::vec4 Color::lightslategray = { 0.467f, 0.533f, 0.600f, 1.0 };
const glm::vec4 Color::lightslategrey = { 0.467f, 0.533f, 0.600f, 1.0 };
const glm::vec4 Color::lightsteelblue = { 0.690f, 0.769f, 0.871f, 1.0 };
const glm::vec4 Color::lightyellow = { 1.000f, 1.000f, 0.878f, 1.0 };
const glm::vec4 Color::lime = { 0.000f, 1.000f, 0.000f, 1.0 };
const glm::vec4 Color::limegreen = { 0.196f, 0.804f, 0.196f, 1.0 };
const glm::vec4 Color::linen = { 0.980f, 0.941f, 0.902f, 1.0 };
const glm::vec4 Color::magenta = { 1.000f, 0.000f, 1.000f, 1.0 };
const glm::vec4 Color::maroon = { 0.502f, 0.000f, 0.000f, 1.0 };
const glm::vec4 Color::mediumaquamarine = { 0.400f, 0.804f, 0.667f, 1.0 };
const glm::vec4 Color::mediumblue = { 0.000f, 0.000f, 0.804f, 1.0 };
const glm::vec4 Color::mediumorchid = { 0.729f, 0.333f, 0.827f, 1.0 };
const glm::vec4 Color::mediumpurple = { 0.576f, 0.439f, 0.859f, 1.0 };
const glm::vec4 Color::mediumseagreen = { 0.235f, 0.702f, 0.443f, 1.0 };
const glm::vec4 Color::mediumslateblue = { 0.482f, 0.408f, 0.933f, 1.0 };
const glm::vec4 Color::mediumspringgreen = { 0.000f, 0.980f, 0.604f, 1.0 };
const glm::vec4 Color::mediumturquoise = { 0.282f, 0.820f, 0.800f, 1.0 };
const glm::vec4 Color::mediumvioletred = { 0.780f, 0.082f, 0.522f, 1.0 };
const glm::vec4 Color::midnightblue = { 0.098f, 0.098f, 0.439f, 1.0 };
const glm::vec4 Color::mintcream = { 0.961f, 1.000f, 0.980f, 1.0 };
const glm::vec4 Color::mistyrose = { 1.000f, 0.894f, 0.882f, 1.0 };
const glm::vec4 Color::moccasin = { 1.000f, 0.894f, 0.710f, 1.0 };
const glm::vec4 Color::navajowhite = { 1.000f, 0.871f, 0.678f, 1.0 };
const glm::vec4 Color::navy = { 0.000f, 0.000f, 0.502f, 1.0 };
const glm::vec4 Color::oldlace = { 0.992f, 0.961f, 0.902f, 1.0 };
const glm::vec4 Color::olive = { 0.502f, 0.502f, 0.000f, 1.0 };
const glm::vec4 Color::olivedrab = { 0.420f, 0.557f, 0.137f, 1.0 };
const glm::vec4 Color::orange = { 1.000f, 0.647f, 0.000f, 1.0 };
const glm::vec4 Color::orangered = { 1.000f, 0.271f, 0.000f, 1.0 };
const glm::vec4 Color::orchid = { 0.855f, 0.439f, 0.839f, 1.0 };
const glm::vec4 Color::palegoldenrod = { 0.933f, 0.910f, 0.667f, 1.0 };
const glm::vec4 Color::palegreen = { 0.596f, 0.984f, 0.596f, 1.0 };
const glm::vec4 Color::paleturquoise = { 0.686f, 0.933f, 0.933f, 1.0 };
const glm::vec4 Color::palevioletred = { 0.859f, 0.439f, 0.576f, 1.0 };
const glm::vec4 Color::papayawhip = { 1.000f, 0.937f, 0.835f, 1.0 };
const glm::vec4 Color::peachpuff = { 1.000f, 0.855f, 0.725f, 1.0 };
const glm::vec4 Color::peru = { 0.804f, 0.522f, 0.247f, 1.0 };
const glm::vec4 Color::pink = { 1.000f, 0.753f, 0.796f, 1.0 };
const glm::vec4 Color::plum = { 0.867f, 0.627f, 0.867f, 1.0 };
const glm::vec4 Color::powderblue = { 0.690f, 0.878f, 0.902f, 1.0 };
const glm::vec4 Color::purple = { 0.502f, 0.000f, 0.502f, 1.0 };
const glm::vec4 Color::red = { 1.000f, 0.000f, 0.000f, 1.0 };
const glm::vec4 Color::rosybrown = { 0.737f, 0.561f, 0.561f, 1.0 };
const glm::vec4 Color::royalblue = { 0.255f, 0.412f, 0.882f, 1.0 };
const glm::vec4 Color::saddlebrown = { 0.545f, 0.271f, 0.075f, 1.0 };
const glm::vec4 Color::salmon = { 0.980f, 0.502f, 0.447f, 1.0 };
const glm::vec4 Color::sandybrown = { 0.957f, 0.643f, 0.376f, 1.0 };
const glm::vec4 Color::seagreen = { 0.180f, 0.545f, 0.341f, 1.0 };
const glm::vec4 Color::seashell = { 1.000f, 0.961f, 0.933f, 1.0 };
const glm::vec4 Color::sienna = { 0.627f, 0.322f, 0.176f, 1.0 };
const glm::vec4 Color::silver = { 0.753f, 0.753f, 0.753f, 1.0 };
const glm::vec4 Color::skyblue = { 0.529f, 0.808f, 0.922f, 1.0 };
const glm::vec4 Color::slateblue = { 0.416f, 0.353f, 0.804f, 1.0 };
const glm::vec4 Color::slategray = { 0.439f, 0.502f, 0.565f, 1.0 };
const glm::vec4 Color::slategrey = { 0.439f, 0.502f, 0.565f, 1.0 };
const glm::vec4 Color::snow = { 1.000f, 0.980f, 0.980f, 1.0 };
const glm::vec4 Color::springgreen = { 0.000f, 1.000f, 0.498f, 1.0 };
const glm::vec4 Color::steelblue = { 0.275f, 0.510f, 0.706f, 1.0 };
const glm::vec4 Color::tan = { 0.824f, 0.706f, 0.549f, 1.0 };
const glm::vec4 Color::teal = { 0.000f, 0.502f, 0.502f, 1.0 };
const glm::vec4 Color::thistle = { 0.847f, 0.749f, 0.847f, 1.0 };
const glm::vec4 Color::tomato = { 1.000f, 0.388f, 0.278f, 1.0 };
const glm::vec4 Color::turquoise = { 0.251f, 0.878f, 0.816f, 1.0 };
const glm::vec4 Color::violet = { 0.933f, 0.510f, 0.933f, 1.0 };
const glm::vec4 Color::wheat = { 0.961f, 0.871f, 0.702f, 1.0 };
const glm::vec4 Color::white = { 1.000f, 1.000f, 1.000f, 1.0 };
const glm::vec4 Color::whitesmoke = { 0.961f, 0.961f, 0.961f, 1.0 };
const glm::vec4 Color::yellow = { 1.000f, 1.000f, 0.000f, 1.0 };
const glm::vec4 Color::yellowgreen = { 0.604f, 0.804f, 0.196f, 1.0 };





void Helper::print ( const char *info, ERROR_TYPE error,
					 const char *funcname, int line, const char *filename )
{
	Helper::print ( ( char * ) info, error, funcname, line, filename );
}

void Helper::print ( char *info, ERROR_TYPE error,
					 const char *funcname, int line, const char *filename )
{
	std::cerr
		<< "ERROR: \""						// ERROR: "
		<< info								// INFO
		<< "\", \n\nCODE: \""					// ", CODE: "
		<< errorTranslater ( error )	// error type
		<< " "								// 
		<< ( int ) error					// error_code
		<< "\", at function: \""			// ", at function: "
		<< funcname							// function name
		<< "\", \nin file: \""				// ", in file "
		<< filename							// filename
		<< "\" line: "						// " line: 
		<< line								// line number
		<< std::endl;
}

std::string Helper::errorTranslater ( ERROR_TYPE error )
{
	#define CASE(Enum, code) \
	case Enum: \
		return std::string(code); \
		break

	switch ( error )
	{
		CASE ( ERROR_TYPE::EmptyString, "EmptyString" );
		CASE ( ERROR_TYPE::NullPtr, "NullPtr" );
		CASE ( ERROR_TYPE::LinkError, "LinkError" );
		CASE ( ERROR_TYPE::CompileError, "CompileError" );
		CASE ( ERROR_TYPE::FileNotExit, "FileNotExit" );
		CASE ( ERROR_TYPE::InvalidShader, "InvalidShader" );
		CASE ( ERROR_TYPE::EmptyMatrixVertex, "EmptyMatrixVertex" );
		CASE ( ERROR_TYPE::GLFWFail, "GLFWFail" );
		CASE ( ERROR_TYPE::WindowFail, "WindowFail" );
		CASE ( ERROR_TYPE::InvalidProgram, "InvalidProgram" );
		#undef CASE
	default:
		return std::string ( "UndefinedERROR" );
	}
}


std::string Helper::fileLoader ( const char *filename, GLint *length )
{
	DEBUG ( length == NULL, ERROR_TYPE::NullPtr );
	DEBUG ( filename == NULL, ERROR_TYPE::NullPtr );

	std::ifstream fs ( filename );

	DEBUG ( !fs.is_open (), ERROR_TYPE::FileNotExit );

	std::string s = std::string ( std::istreambuf_iterator<char> ( fs ), std::istreambuf_iterator<char> () );

	DEBUG ( s.empty (), ERROR_TYPE::EmptyString );

	*length = ( GLint ) s.length ();
	s = s;
	return s;
}



void Helper::shaderLoader ( GLuint shader, const char *filename )
{
	DEBUG ( !glIsShader ( shader ), ERROR_TYPE::InvalidShader );
	DEBUG ( filename == "", ERROR_TYPE::EmptyString );

	GLint length;
	const char *text;
	std::string s = fileLoader ( filename, &length ).c_str ();

	DEBUG ( s.empty (), ERROR_TYPE::FileNotExit );

	text = s.c_str ();
	glShaderSource ( shader, 1, &text, &length );
}

void Helper::shaderCompiler ( GLuint shader )
{
	DEBUG ( !glIsShader ( shader ), ERROR_TYPE::InvalidShader );
	GLint status;

	glCompileShader ( shader );

	glGetShaderiv ( shader, GL_COMPILE_STATUS, &status );
	if ( !status )
	{
		char *errorLog = ( char * ) malloc ( ( size_t ) 512 );
		glGetShaderInfoLog ( shader, ( GLsizei ) 512, NULL, errorLog );

		DEBUGP ( errorLog, ERROR_TYPE::CompileError );
	}
}

void Helper::shaderAttacher ( GLuint program, GLuint shader )
{
	DEBUG ( !glIsShader ( shader ), ERROR_TYPE::InvalidShader );
	DEBUG ( !glIsProgram ( program ), ERROR_TYPE::InvalidProgram );

	glAttachShader ( program, shader );

}

void Helper::shaderWorker ( GLuint program, GLuint shader,
							const char *filename )
{
	shaderLoader ( shader, filename );
	shaderCompiler ( shader );
	shaderAttacher ( program, shader );
}

Model Helper::vertexLoader ( const char *filename )
{
	GLint length, numMatrixes, numVertices, numElements;
	Model mo;

	std::string s = fileLoader ( filename, &length );
	std::istringstream iss ( s, std::ios_base::in );
	std::string Modelname;

	// Get number of matrixes and filename
	iss >> numMatrixes >> Modelname;
	mo.addName ( Modelname );

	// read matrixes
	for ( int matrix_num = 0; matrix_num < numMatrixes; matrix_num++ )
	{
		Matrix ma;
		std::string matrixname;

		iss >> numVertices >> numElements >> matrixname;
		ma.addName ( matrixname );

		// read vertices
		for ( int vertex_num = 0; vertex_num < numVertices; vertex_num++ )
		{
			std::vector<GLfloat> vertex_;

			// Read element
			for ( int element_num = 0; element_num < numElements; element_num++ )
			{
				GLfloat element;
				iss >> element;
				vertex_.push_back ( element );

			}
			if ( numElements == 2 )
			{
				vertex_.push_back ( 0.0f );
				vertex_.push_back ( 1.0f );
			} else if ( numElements == 3 )
			{
				vertex_.push_back ( 1.0f );
			}
			glm::vec4 vertex ( vertex_[0], vertex_[1], vertex_[2], vertex_[3] );
			ma.addVertex ( vertex );
		}
		mo.addMatrix ( ma );

	}
	return mo;
}

void Helper::elementLoader ( Model *model, const char *filename )
{
	GLint length, numMatrixes, numVertices, numElements;
	std::string s = fileLoader ( filename, &length );
	std::istringstream iss ( s, std::ios_base::in );
	std::string Modelname;
	iss >> numMatrixes >> Modelname;

	// read matrix
	for ( int matrix_num = 0; matrix_num < numMatrixes; matrix_num++ )
	{
		std::string matrixname;
		iss >> numVertices >> numElements >> matrixname;


		// read vertices
		for ( int vertex_num = 0; vertex_num < numVertices; vertex_num++ )
		{
			unsigned int row_[3];
			// Read element
			iss >> row_[0] >> row_[1] >> row_[2];
			glm::uvec3 row ( row_[0], row_[1], row_[2] );
			model->matrixes[matrix_num].addElement ( row );
		}
	}
}


size_t
Helper::typeSize ( GLenum type )
{
	size_t size;

	#define CASE(Enum, Count, Type) \
	case Enum: size = Count * sizeof (Type); break

	switch ( type )
	{
		CASE ( GL_FLOAT, 1, GLfloat );
		CASE ( GL_FLOAT_VEC2, 2, GLfloat );
		CASE ( GL_FLOAT_VEC3, 3, GLfloat );
		CASE ( GL_FLOAT_VEC4, 4, GLfloat );
		CASE ( GL_INT, 1, GLint );
		CASE ( GL_INT_VEC2, 2, GLint );
		CASE ( GL_INT_VEC3, 3, GLint );
		CASE ( GL_INT_VEC4, 4, GLint );
		CASE ( GL_UNSIGNED_INT, 1, GLuint );
		CASE ( GL_UNSIGNED_INT_VEC2, 2, GLuint );
		CASE ( GL_UNSIGNED_INT_VEC3, 3, GLuint );
		CASE ( GL_UNSIGNED_INT_VEC4, 4, GLuint );
		CASE ( GL_BOOL, 1, GLboolean );
		CASE ( GL_BOOL_VEC2, 2, GLboolean );
		CASE ( GL_BOOL_VEC3, 3, GLboolean );
		CASE ( GL_BOOL_VEC4, 4, GLboolean );
		CASE ( GL_FLOAT_MAT2, 4, GLfloat );
		CASE ( GL_FLOAT_MAT2x3, 6, GLfloat );
		CASE ( GL_FLOAT_MAT2x4, 8, GLfloat );
		CASE ( GL_FLOAT_MAT3, 9, GLfloat );
		CASE ( GL_FLOAT_MAT3x2, 6, GLfloat );
		CASE ( GL_FLOAT_MAT3x4, 12, GLfloat );
		CASE ( GL_FLOAT_MAT4, 16, GLfloat );
		CASE ( GL_FLOAT_MAT4x2, 8, GLfloat );
		CASE ( GL_FLOAT_MAT4x3, 12, GLfloat );
		#undef CASE
	default:
		fprintf ( stderr, "Unknown type: -x%x\n", type );
		exit ( EXIT_FAILURE );
		break;
	}
	return size;
}


Model::Model ()
{

}

int Model::length ()
{
	return ( int ) this->matrixes.size ();
}

std::string Model::getName ()
{
	return this->name;
}

bool Model::addName ( std::string name )
{
	this->name = name;
	return true;
}

bool Model::addMatrix ( Matrix matrix )
{
	this->matrixes.push_back ( matrix );
	return true;
}

Matrix Model::getMatrix ( int number )
{
	return this->matrixes[number];
}


std::vector< Matrix > Model::getModel ()
{
	return this->matrixes;
}


Matrix::Matrix ()
{

}


bool Matrix::addName ( std::string name )
{
	this->name = name;
	return true;
}

bool Matrix::addVertex ( glm::vec4 vertex )
{
	this->vertices.push_back ( vertex );
	return true;
}

int Matrix::vSize ()
{
	return ( int )
		( this->vertices.size () * Helper::typeSize ( GL_FLOAT_VEC4 ) );
}

int Matrix::eSize ()
{
	return ( int )
		( elements.size () * Helper::typeSize ( GL_UNSIGNED_INT_VEC3 ) );
}



std::string Matrix::getName ()
{
	return this->name;
}

std::vector<glm::vec4> Matrix::getVector ()
{
	return this->vertices;
}

glm::vec4 Matrix::getVertex ( int num )
{
	return vertices[num];
}

void *Matrix::getVAddress ()
{
	return &vertices[0];
}

void *Matrix::getEAddress ()
{
	return &elements[0];
}

glm::ivec3 Matrix::getElement ( int num )
{
	return elements[num];
}

bool Matrix::addElement ( glm::uvec3 element )
{
	this->elements.push_back ( element );
	return true;
}

std::vector<glm::uvec3> Matrix::getElementArray ()
{
	return elements;
}

void glClearColorfv ( const glm::vec4 color )
{
	glClearColor ( color.r, color.g, color.b, color.a );
}

void glUniformRGBA ( GLint location, glm::vec4 color )
{
	glUniform4f ( location, color.r, color.g, color.b, color.a );
}
